# Copyright (c) 2023 Matthias Wolf, Mawosoft.

<#
.SYNOPSIS
    Converts markdown help generated by platyPS to markdown for use with DocFx.

.DESCRIPTION
    - TODO the actual conversion and description of conversion steps
    - Generates index-All.md and index-<noun>.md files containing cmdlet indices with link and synopsis.
    The conversion adjusts for HTML formatting capabilities of DocFx, e.g. the yml code of
    parameter properties is converted into a table.
    Also generates an 'includes' subdirectory in destination with index.md and index-<noun>.md files,
    containing cmdlet indices with link and synopsis (all cmdlets and cmdlets per noun).
#>

#Requires -Version 7

using namespace System
using namespace System.Collections
using namespace System.Net
using namespace System.Text

[CmdletBinding()]
param(
    # Source directory containing the markdown help file(s) created by platyPS
    [Parameter(Mandatory = $false, Position = 0)]
    [ValidateNotNullOrEmpty()]
    [string]$Path = "$PSScriptRoot/../docs/help",

    # Destination directory for converted markdown files.
    [Parameter(Mandatory = $false, Position = 1)]
    [ValidateNotNullOrEmpty()]
    [string]$Destination = "$PSScriptRoot/../docs/reference",

    # Always write to output file, even if content is unchanged.
    [switch]$WriteAlways
)

Set-StrictMode -Version 3.0
$ErrorActionPreference = 'Stop'

# Write content to file if changed or -WriteAlways is specified
function Update-Content {
    [CmdletBinding()]
    param(
        # Path of the file
        [Parameter(Mandatory, Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string]$Path,
        # Content to write
        [Parameter(Mandatory, Position = 1, ValueFromPipeline)]
        [Object[]]$Value,
        # Suppress newline
        [switch]$NoNewline
    )

    begin {
        [StringBuilder]$sb = [StringBuilder]::new()

        # Append to $content while flattening input
        function Append {
            param([object]$obj)

            if ($obj -is [IList]) {
                foreach ($o in $obj) { Append $o }
            }
            else {
                $null = $sb.Append($obj)
                if (-not $NoNewline) { $null = $sb.AppendLine() }
            }
        }
    }
    process {
        Append $Value
    }
    end {
        [string]$content = $sb.ToString()
        if ($WriteAlways -or -not (Test-Path $Path -PathType Leaf) -or
            -not $content.Equals((Get-Content $Path -Raw), [StringComparison]::Ordinal)) {
            $content | Set-Content -Path $Path -NoNewline
        }
    }
}


if (-not (Test-Path $Path -PathType Container)) {
    throw "Directory does not exist: $Path"
}
if (-not (Test-Path $Destination -PathType Container)) {
    throw "Directory does not exist: $Destination"
}

[string]$includesPath = Join-Path $Destination 'includes'
if (-not (Test-Path $includesPath -PathType Container)) {
    $null = New-Item $includesPath -ItemType Directory
}

[ArrayList]$cmdlets = @()

Join-Path $Path '*-*.md' | Get-ChildItem | ForEach-Object {
    [string]$content = Get-Content -Path $_ -Raw
    # TODO convert
    [string]$destinationFile = Join-Path $Destination $_.Name
    $content | Update-Content -Path $destinationFile -NoNewline
    $null = $cmdlets.Add([PSCustomObject]@{
            Name     = $_.BaseName
            Noun     = $_.BaseName.Split([char]'-', 2)[1]
            # Normally, links in an include file are relative to that include file, but apparently not for inline HTML.
            TableRow = '<tr><td><a href="' + $_.BaseName + '.md">' + [WebUtility]::HtmlEncode($_.BaseName) + '</td><td>' +
            [WebUtility]::HtmlEncode('TODO extracted synopsis goes here') + '</td></tr>'
        })
}

'<table>', ($cmdlets | Sort-Object Name).TableRow, '</table>' | Update-Content -Path (Join-Path $includesPath 'index-All.md')

$cmdlets | Group-Object Noun | ForEach-Object {
    '<table>', ($_.Group | Sort-Object Name).TableRow, '</table>' | Update-Content -Path (Join-Path $includesPath "index-$($_.Name).md")
}
